////////////////////////////////////////////////////
// This is an AutoGenerated class created by Rocketlane for its Salesforce integration
// DO NOT EDIT OR DELETE THIS CLASS
////////////////////////////////////////////////////


public class RLSTAGEWH394 implements Queueable,Database.AllowsCallouts {

    List<String> fieldsToFetchChildRecordsFor;
    List<String> fieldsBeingListenedForUpdates;

    RLSTAGEWH394.TriggerContext triggerContext;

    public RLSTAGEWH394(RLSTAGEWH394.TriggerContext triggerContext, List<String> fieldsToFetchChildRecordsFor, List<String> fieldsBeingListenedForUpdates) {
        this.triggerContext = triggerContext;
        this.fieldsToFetchChildRecordsFor = fieldsToFetchChildRecordsFor;
        this.fieldsBeingListenedForUpdates = fieldsBeingListenedForUpdates;
    }



    public class TriggerContext {
        SObjectType sObjectType;
        Boolean isExecuting;
        Boolean isInsert;
        Boolean isUpdate;
        Boolean isDelete;
        Boolean isUndelete;
        Boolean isBefore;
        Boolean isAfter;
        List<SObject> newList;
        Map<ID, SObject> newMap;
        List<SObject> oldList;
        Map<ID, SObject> oldMap;
        Integer size;

        public TriggerContext(SObjectType sObjectType,
                              Boolean isExecuting,
                              Boolean isInsert,
                              Boolean isUpdate,
                              Boolean isDelete,
                              Boolean isUndelete,
                              Boolean isBefore,
                              Boolean isAfter,
                              List<SObject> newList,
                              Map<ID, SObject> newMap,
                              List<SObject> oldList,
                              Map<ID, SObject> oldMap,
                              Integer size){
            this.sObjectType = sObjectType;
            this.isExecuting = isExecuting;
            this.isInsert = isInsert;
            this.isUpdate = isUpdate;
            this.isDelete = isDelete;
            this.isUndelete = isUndelete;
            this.isBefore = isBefore;
            this.isAfter = isAfter;
            this.newList = newList;
            this.newMap = newMap;
            this.oldList = oldList;
            this.oldMap = oldMap;
            this.size = size;
        }
    }


    public class TriggerPayload {
        SObject oldObj;
        SObject newObj;
        String action;
        String sObjectType;
        Map<String, SObject> childRecords;

        public TriggerPayload(SObject oldObj, SObject newObj, String action, SObjectType sObjectType, Map<String, SObject> childRecords) {
            this.oldObj = oldObj;
            this.newObj = newObj;
            this.action = action;
            this.sObjectType = String.valueOf(sObjectType);
            this.childRecords = childRecords;
        }
    }


    public static void sendPayload(TriggerPayload payload) {
        System.debug('serializing payload');
        String payloadJson = JSON.serialize(payload);
        RLSTAGEWH394.sendPayloadStr(payloadJson);
    }

    public static void sendPayloadStr(String payloadJson) {

        try {
            System.debug('sending payload');

            HTTP h = new HTTP();
            HTTPRequest req = new HTTPRequest();

            req.setEndpoint('https://atlan.api.rocketlane.com/api/hooks/integrations/salesforce/394?authKey=492a16b1-d04a-45fb-a00b-ac2e672f924a');
            req.setMethod('POST');
            //req.setCompressed(true);
            req.setBody(payloadJson);
            req.setHeader('Content-Type', 'application/json');

            HTTPResponse res = h.send(req);
            System.debug('sent payload');
        }
        catch(Exception e) {
            System.debug('Exception when sending payload: ' + e.getMessage());
            System.debug(e.getStackTraceString());
        }
    }


    public Map<String, SObject> fetchChildRecords(SObjectType sObjectType, List<SObject> oldObjs, List<SObject> newObjs) {
        Map<String, Schema.SObjectField> parentFieldsMap = sObjectType.getDescribe().fields.getMap();

        Map<String, SObject> childRecordsMap = new Map<String, SObject>();
        List<SObject> allObjs = new List<SObject>();
        if(oldObjs != null) {
            allObjs.addAll(oldObjs);
        }
        if(newObjs != null) {
            allObjs.addAll(newObjs);
        }

        List<String> fieldsToFetchChildRecordsForLowercased = new List<String>(); //need this because keys are lowercased
        for(String f: fieldsToFetchChildRecordsFor) {
            fieldsToFetchChildRecordsForLowercased.add(f.toLowerCase());
        }

        for(SObject sObjectRecord: allObjs) {
            //NOTE: .getDescribe().fields.getMap() seems to lowercase the map-keys(i.e the fieldNames) by default
            for (String fieldNameLowerCased : parentFieldsMap.keySet()) {

                //if field is not registered for child record fetching, no need to proceed
                if(!fieldsToFetchChildRecordsForLowercased.contains(fieldNameLowerCased)) continue;

                //if field value is null, no need to proceed
                if(sObjectRecord.get(fieldNameLowerCased)==null) {
                    System.debug('Field ' + fieldNameLowerCased + ' - value is null');
                    continue;
                }

                //if field is not a reference, no need ot proceed
                DescribeFieldResult fieldDescription = parentFieldsMap.get(fieldNameLowerCased).getDescribe();
                Schema.DisplayType fieldType = fieldDescription.getType();
                if(fieldType != Schema.DisplayType.REFERENCE) {
                    System.debug('Field ' + fieldNameLowerCased + ' - not a reference field');
                    continue;
                }

                //if childObject has already been fetched, no need to proceed
                String childRecordId = (String)sObjectRecord.get(fieldNameLowerCased);
                if(childRecordsMap.get(childRecordId) != null) {
                    System.debug('Field ' + fieldNameLowerCased + ' - record has already been fetched');
                    continue;
                }


                //fetch the child recordId and child recordType
                List <Schema.sObjectType> referenceTo = fieldDescription.getReferenceTo();

                for (Schema.SObjectType childSObjectType: referenceTo) {
                     System.debug('Fetching child record ' + childSObjectType + ':' + childRecordId + ' for field ' + fieldNameLowerCased);
                     String query = 'select FIELDS(STANDARD) from ' + childSObjectType + ' where Id = \'' + childRecordId + '\'';
                     List<SObject> childRecords = Database.query(query);
                     if(childRecords.isEmpty()) continue;

                    //populate in map
                    childRecordsMap.put(childRecordId, childRecords.get(0));
                }
            }
        }
        return childRecordsMap;
    }



    private List<String> getChangedFields(SObjectType sObjectType, SObject oldObj, SObject newObj) {

        List<String> changedFields = new List<String> {};
        Map<String, Schema.SObjectField> fieldsMap = sObjectType.getDescribe().fields.getMap();
        for (String fieldNameLowerCased : fieldsMap.keySet()) {
            Object oldObjVal = oldObj.get(fieldNameLowerCased);
            Object newObjVal = newObj.get(fieldNameLowerCased);
            if (didFieldChange(oldObjVal, newObjVal)) {
                changedFields.add(fieldNameLowerCased);
            }
        }
        return changedFields;
    }

    private static Boolean didFieldChange(Object v1, Object v2) {
        if (v1 == null && v2 == null) {
            return false;
        }
        if (v1 != v2) {
            return true;
        }
        return false;
    }

    private static boolean doListsIntersect(List<String> l1, List<String> l2) {
        for(String s1: l1) {
            if(l2.contains(s1)) {
                return true;
            }
        }
        return false;
    }



    public void execute(QueueableContext context) {

        try {
            RLSTAGEWH394.TriggerContext tc = this.triggerContext;
            String action = tc.isInsert?'INSERT':(tc.isUpdate?'UPDATE':(tc.isDelete?'DELETE':(tc.isUndelete?'UNDELETE':'UNKNOWN')));
            System.debug('Received Event "' + action + '" for resource "' + tc.sObjectType + '" with childFields "' + fieldsToFetchChildRecordsFor + '"' );

            Map<String, SObject> childRecords = this.fetchChildRecords(tc.sObjectType, tc.oldList, tc.newList);

            if(tc.isInsert || tc.isUndelete) {
                for(Id objId: tc.newMap.keySet()) {
                    System.debug('preparing payload for sObject ' + objId + ':' + action);
                    SObject oldObj = null;
                    SObject newObj = tc.newMap.get(objId);
                    TriggerPayload payload = new TriggerPayload(oldObj,newObj,action,tc.sObjectType,childRecords);
                    RLSTAGEWH394.sendPayload(payload);
                }
            }
            else if (tc.isUpdate) {
                for(Id objId: tc.newMap.keySet()) {
                    System.debug('preparing payload for sObject ' + objId + ':' + action);

                    SObject oldObj = tc.oldMap.get(objId);
                    SObject newObj = tc.newMap.get(objId);

                    //get changed fields
                    List<String> fieldsBeingListenedForUpdatesLowerCased = new List<String>(); //need this because keys are lowercased
                    for(String f: fieldsBeingListenedForUpdates) {
                        fieldsBeingListenedForUpdatesLowerCased.add(f.toLowerCase());
                    }
                    List<String> changedFieldsLowerCased = getChangedFields(tc.sObjectType, oldObj, newObj);
                    System.debug('Changed fields ' + changedFieldsLowerCased);
                    if(!doListsIntersect(fieldsBeingListenedForUpdatesLowerCased, changedFieldsLowerCased)) {
                        System.debug('None of the changed fields are being listened by Rocketlane ');
                        continue;
                    }

                    TriggerPayload payload = new TriggerPayload(oldObj,newObj,action,tc.sObjectType,childRecords);
                    RLSTAGEWH394.sendPayload(payload);
                }
            }
            else if (tc.isDelete) {
                for(Id objId: tc.oldMap.keySet()) {
                    System.debug('preparing payload for sObject ' + objId + ':' + action);
                    SObject oldObj = tc.oldMap.get(objId);
                    SObject newObj = null;
                    TriggerPayload payload = new TriggerPayload(oldObj,newObj,action,tc.sObjectType,childRecords);
                    RLSTAGEWH394.sendPayload(payload);
                }
            }
        }
        catch(Exception e) {
            System.debug('Exception when sending webhook: ' + e.getMessage());
            System.debug(e.getStackTraceString());
        }
    }
}